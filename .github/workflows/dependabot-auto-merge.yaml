name: Dependabot Auto-Merge

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  dependabot-auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Checkout the PR branch to allow pushing commits
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true
          cache-dependency-path: go.sum

      - name: Check SDK generation
        run: |
          git status --porcelain > /tmp/before_gen_sdk.txt

          make gen-sdk

          # Check git status
          git status --porcelain > /tmp/after_gen_sdk.txt

          # Compare the two status files
          if ! diff -q /tmp/before_gen_sdk.txt /tmp/after_gen_sdk.txt > /dev/null; then
            # Get list of changed file paths
            CHANGED_FILES=$(git status --porcelain | awk '{print $2}')

            # allowed files that can be auto-committed
            ALLOWED_FILES=("sdk/go/go.mod" "sdk/go/go.sum")

            # Check if changed files are only allowed ones
            UNAUTHORIZED_CHANGES=0
            if [ -n "$CHANGED_FILES" ]; then
              while IFS= read -r file; do
                if [ -n "$file" ]; then
                  # Check if file is in allowed list
                  IS_ALLOWED=0
                  for allowed_file in "${ALLOWED_FILES[@]}"; do
                    if [ "$file" = "$allowed_file" ]; then
                      IS_ALLOWED=1
                      break
                    fi
                  done
                  if [ "$IS_ALLOWED" -eq 0 ]; then
                    UNAUTHORIZED_CHANGES=1
                    break
                  fi
                fi
              done <<< "$CHANGED_FILES"
            fi

            if [ "$UNAUTHORIZED_CHANGES" -eq 1 ]; then
              echo "‚ùå SDK is not up to date in the repo. Make sure to run 'make gen-sdk && make gen-sdk-dockerized' and commit."
              echo "Files changed:"
              git status --porcelain
              echo ""
              exit 1
            else
              echo "‚úÖ Only ${ALLOWED_FILES[@]} changed. Will commit and push to PR branch."
            fi
          else
            echo "‚úÖ SDK is up to date."
          fi

      - name: Commit and push SDK Go module changes
        id: commit_changes
        run: |
          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            # Configure git user for commits
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            # Set up remote URL with token for pushing
            git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

            # Add only the allowed files
            git add sdk/go/go.mod sdk/go/go.sum

            # Check if there are staged changes
            if [ -n "$(git diff --cached --name-only)" ]; then
              PR_BRANCH="${{ github.head_ref }}"

              # Don't use [skip ci] so workflows run on the new commit
              git commit -m "chore: update SDK Go module dependencies"

              # Get the commit SHA before pushing (this is the commit we're about to push)
              NEW_SHA=$(git rev-parse HEAD)
              echo "üìù Created commit $NEW_SHA"

              # Push the commit
              git push origin HEAD:$PR_BRANCH

              # Fetch to ensure we have the latest remote state
              git fetch origin $PR_BRANCH

              # Verify the commit exists on the remote and get the remote commit SHA
              REMOTE_SHA=$(git rev-parse origin/$PR_BRANCH)

              if [ "$NEW_SHA" != "$REMOTE_SHA" ]; then
                echo "‚ö†Ô∏è Warning: Local commit SHA ($NEW_SHA) differs from remote SHA ($REMOTE_SHA)"
                echo "Using remote SHA for tagging: $REMOTE_SHA"
                NEW_SHA="$REMOTE_SHA"
              else
                echo "‚úÖ Verified commit $NEW_SHA exists on remote branch $PR_BRANCH"
              fi

              echo "‚úÖ Committed and pushed SDK Go module changes to PR branch: $PR_BRANCH"
              echo "committed=true" >> $GITHUB_OUTPUT
              echo "new_sha=$NEW_SHA" >> $GITHUB_OUTPUT
            else
              echo "‚ÑπÔ∏è No changes to commit for SDK Go modules."
              echo "committed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è No changes detected."
            echo "committed=false" >> $GITHUB_OUTPUT
          fi

      - name: Wait for Develop workflow to be registered
        if: steps.commit_changes.outputs.committed == 'true'
        run: |
          WORKFLOW_FILE="develop.yaml"
          PR_SHA="${{ steps.commit_changes.outputs.new_sha }}"
          MAX_WAIT_SECONDS=60
          POLL_INTERVAL_SECONDS=5
          MAX_ITERATIONS=$((MAX_WAIT_SECONDS / POLL_INTERVAL_SECONDS))

          echo "‚è≥ Waiting for '$WORKFLOW_FILE' workflow to be registered on commit $PR_SHA..."
          echo "GitHub's auto-merge will wait for the workflow to complete once it's registered."

          # Wait a moment for GitHub to process the push event
          sleep 5

          for i in $(seq 1 $MAX_ITERATIONS); do
            # Check if workflow run exists for this commit
            RUN_ID=$(gh run list \
              --workflow="$WORKFLOW_FILE" \
              --commit="$PR_SHA" \
              --json databaseId \
              --jq '.[0].databaseId' \
              --limit 1 2>/dev/null || echo "")

            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "‚úÖ Workflow run $RUN_ID registered. GitHub auto-merge will wait for it to complete."
              exit 0
            fi

            if [ $i -lt $MAX_ITERATIONS ]; then
              echo "‚è≥ Workflow not registered yet (attempt $i/$MAX_ITERATIONS)..."
              sleep $POLL_INTERVAL_SECONDS
            fi
          done

          echo "‚ö†Ô∏è Workflow not registered after $MAX_WAIT_SECONDS seconds, but proceeding with auto-merge."
          echo "GitHub will wait for any checks that become available."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge for Dependabot PRs
        run: |
          gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version and increment patch
        id: version
        run: |
          # Fetch tags from remote to ensure we have the latest
          git fetch --tags

          # Get the latest tag (version tag should start with 'v')
          # Use git tag -l instead of git describe to find tags regardless of current branch history
          LATEST_TAG=$(git tag -l 'v*' | sort -V | tail -1)

          # If no tags found, default to v0.0.0
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          # Remove 'v' prefix and split version
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Previous version: $LATEST_TAG"
          echo "New version: $NEW_VERSION"

      - name: Create and push tag
        run: |
          # Configure git user for tagging
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Set up remote URL with token for pushing
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

          # Fetch latest to ensure we have the most up-to-date refs
          git fetch origin

          # Ensure we're on the PR branch and it's up to date
          PR_BRANCH="${{ github.head_ref }}"
          git checkout -B "$PR_BRANCH" "origin/$PR_BRANCH" 2>/dev/null || git checkout "$PR_BRANCH"
          echo "üìç Currently on branch: $(git branch --show-current)"
          echo "üìç HEAD is at: $(git rev-parse HEAD)"

          # Determine which commit to tag
          if [ "${{ steps.commit_changes.outputs.committed }}" = "true" ]; then
            # We just created a commit, so tag the current HEAD (which should be our commit)
            # This is more reliable than using the stored SHA which might be stale
            EXPECTED_SHA="${{ steps.commit_changes.outputs.new_sha }}"
            CURRENT_HEAD=$(git rev-parse HEAD)

            echo "Tagging the commit we just created"
            echo "Expected SHA from commit step: $EXPECTED_SHA"
            echo "Current HEAD SHA: $CURRENT_HEAD"

            # Verify HEAD matches what we expect (or is at least the commit we created)
            if [ "$CURRENT_HEAD" != "$EXPECTED_SHA" ]; then
              echo "‚ö†Ô∏è Warning: Current HEAD ($CURRENT_HEAD) differs from expected SHA ($EXPECTED_SHA)"
              echo "Checking if expected commit exists and is reachable..."

              # Check if the expected commit exists
              if git cat-file -e "$EXPECTED_SHA" 2>/dev/null; then
                # Check if it's an ancestor of HEAD (meaning HEAD has moved forward)
                if git merge-base --is-ancestor "$EXPECTED_SHA" "$CURRENT_HEAD" 2>/dev/null; then
                  echo "‚úÖ Expected commit is an ancestor of HEAD. New commits were added after our commit."
                  echo "Using current HEAD ($CURRENT_HEAD) for tagging, which is the latest commit."
                  TAG_COMMIT="$CURRENT_HEAD"
                else
                  echo "‚ö†Ô∏è Expected commit exists but is not an ancestor of HEAD. Using HEAD."
                  TAG_COMMIT="$CURRENT_HEAD"
                fi
              else
                echo "‚ö†Ô∏è Expected commit not found. Using current HEAD."
                TAG_COMMIT="$CURRENT_HEAD"
              fi
            else
              echo "‚úÖ Verified: Current HEAD matches expected commit SHA"
              TAG_COMMIT="$CURRENT_HEAD"
            fi

            # Show commit details for verification
            echo ""
            echo "üìã Commit that will be tagged:"
            git log -1 --format="  SHA: %H%n  Author: %an <%ae>%n  Date: %ad%n  Message: %s" "$TAG_COMMIT"
          else
            # Tag the current HEAD (PR head commit)
            TAG_COMMIT="HEAD"
            echo "Tagging current HEAD (no new commit was created)"

            # Show commit details for verification
            echo "üìã Commit details:"
            git log -1 --format="  SHA: %H%n  Author: %an <%ae>%n  Date: %ad%n  Message: %s" "$TAG_COMMIT"
          fi

          # Create the tag on the specific commit
          git tag "${{ steps.version.outputs.new_version }}" "$TAG_COMMIT"
          echo "‚úÖ Created tag ${{ steps.version.outputs.new_version }} on commit $TAG_COMMIT"

          # Push the tag
          git push origin "${{ steps.version.outputs.new_version }}"
          echo "‚úÖ Pushed tag ${{ steps.version.outputs.new_version }}"
