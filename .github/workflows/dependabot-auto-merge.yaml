name: Dependabot Auto-Merge

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  dependabot-auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Checkout the PR branch to allow pushing commits
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true
          cache-dependency-path: go.sum

      - name: Check SDK generation
        run: |
          git status --porcelain > /tmp/before_gen_sdk.txt

          make gen-sdk

          # Check git status
          git status --porcelain > /tmp/after_gen_sdk.txt

          # Compare the two status files
          if ! diff -q /tmp/before_gen_sdk.txt /tmp/after_gen_sdk.txt > /dev/null; then
            # Get list of changed file paths
            CHANGED_FILES=$(git status --porcelain | awk '{print $2}')

            # allowed files that can be auto-committed
            ALLOWED_FILES=("sdk/go/go.mod" "sdk/go/go.sum")

            # Check if changed files are only allowed ones
            UNAUTHORIZED_CHANGES=0
            if [ -n "$CHANGED_FILES" ]; then
              while IFS= read -r file; do
                if [ -n "$file" ]; then
                  # Check if file is in allowed list
                  IS_ALLOWED=0
                  for allowed_file in "${ALLOWED_FILES[@]}"; do
                    if [ "$file" = "$allowed_file" ]; then
                      IS_ALLOWED=1
                      break
                    fi
                  done
                  if [ "$IS_ALLOWED" -eq 0 ]; then
                    UNAUTHORIZED_CHANGES=1
                    break
                  fi
                fi
              done <<< "$CHANGED_FILES"
            fi

            if [ "$UNAUTHORIZED_CHANGES" -eq 1 ]; then
              echo "❌ SDK is not up to date in the repo. Make sure to run 'make gen-sdk && make gen-sdk-dockerized' and commit."
              echo "Files changed:"
              git status --porcelain
              echo ""
              exit 1
            else
              echo "✅ Only ${ALLOWED_FILES[@]} changed. Will commit and push to PR branch."
            fi
          else
            echo "✅ SDK is up to date."
          fi

      - name: Commit and push SDK Go module changes
        id: commit_changes
        run: |
          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            # Configure git user for commits
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            # Set up remote URL with token for pushing
            git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

            # Add only the allowed files
            git add sdk/go/go.mod sdk/go/go.sum

            # Check if there are staged changes
            if [ -n "$(git diff --cached --name-only)" ]; then
              PR_BRANCH="${{ github.head_ref }}"

              # Don't use [skip ci] so workflows run on the new commit
              git commit -m "chore: update SDK Go module dependencies"
              git push origin HEAD:$PR_BRANCH

              # Get the new commit SHA after pushing
              NEW_SHA=$(git rev-parse HEAD)
              echo "✅ Committed and pushed SDK Go module changes to PR branch: $PR_BRANCH"
              echo "committed=true" >> $GITHUB_OUTPUT
              echo "new_sha=$NEW_SHA" >> $GITHUB_OUTPUT
            else
              echo "ℹ️ No changes to commit for SDK Go modules."
              echo "committed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "ℹ️ No changes detected."
            echo "committed=false" >> $GITHUB_OUTPUT
          fi

      - name: Wait for Develop workflow to be registered
        if: steps.commit_changes.outputs.committed == 'true'
        run: |
          WORKFLOW_FILE="develop.yaml"
          PR_SHA="${{ steps.commit_changes.outputs.new_sha }}"
          MAX_WAIT_SECONDS=60
          POLL_INTERVAL_SECONDS=5
          MAX_ITERATIONS=$((MAX_WAIT_SECONDS / POLL_INTERVAL_SECONDS))

          echo "⏳ Waiting for '$WORKFLOW_FILE' workflow to be registered on commit $PR_SHA..."
          echo "GitHub's auto-merge will wait for the workflow to complete once it's registered."

          # Wait a moment for GitHub to process the push event
          sleep 5

          for i in $(seq 1 $MAX_ITERATIONS); do
            # Check if workflow run exists for this commit
            RUN_ID=$(gh run list \
              --workflow="$WORKFLOW_FILE" \
              --commit="$PR_SHA" \
              --json databaseId \
              --jq '.[0].databaseId' \
              --limit 1 2>/dev/null || echo "")

            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "✅ Workflow run $RUN_ID registered. GitHub auto-merge will wait for it to complete."
              exit 0
            fi

            if [ $i -lt $MAX_ITERATIONS ]; then
              echo "⏳ Workflow not registered yet (attempt $i/$MAX_ITERATIONS)..."
              sleep $POLL_INTERVAL_SECONDS
            fi
          done

          echo "⚠️ Workflow not registered after $MAX_WAIT_SECONDS seconds, but proceeding with auto-merge."
          echo "GitHub will wait for any checks that become available."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge for Dependabot PRs
        run: |
          gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version and increment patch
        id: version
        run: |
          # Fetch tags from remote to ensure we have the latest
          git fetch --tags

          # Get the latest tag (version tag should start with 'v')
          # Use git tag -l instead of git describe to find tags regardless of current branch history
          LATEST_TAG=$(git tag -l 'v*' | sort -V | tail -1)

          # If no tags found, default to v0.0.0
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          # Remove 'v' prefix and split version
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Previous version: $LATEST_TAG"
          echo "New version: $NEW_VERSION"

      - name: Create and push tag
        run: |
          # Configure git user for tagging
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Set up remote URL with token for pushing
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

          # Determine which commit to tag
          if [ "${{ steps.commit_changes.outputs.committed }}" = "true" ]; then
            # Tag the commit we just created
            TAG_COMMIT="${{ steps.commit_changes.outputs.new_sha }}"
            echo "Tagging commit $TAG_COMMIT (the commit we just created)"
          else
            # Tag the current HEAD (PR head commit)
            TAG_COMMIT="HEAD"
            echo "Tagging current HEAD (no new commit was created)"
          fi

          # Create the tag on the specific commit
          git tag "${{ steps.version.outputs.new_version }}" "$TAG_COMMIT"

          # Push the tag
          git push origin "${{ steps.version.outputs.new_version }}"
          echo "✅ Pushed tag ${{ steps.version.outputs.new_version }}"
